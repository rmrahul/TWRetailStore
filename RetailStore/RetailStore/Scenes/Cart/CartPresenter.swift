//
//  CartPresenter.swift
//  RetailStore
//
//  Created by Rahul Mane on 21/07/18.
//  Copyright (c) 2018 developer. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol CartPresentationLogic{
    func presentProducts(response: Cart.FetchProducts.Response)
    func removedProduct(response: Cart.RemoveProduct.Response)
}

class CartPresenter: CartPresentationLogic{
    weak var viewController: CartDisplayLogic?
    private struct Titles{
        static let name = "Name : "
        static let category = "Category : "
        static let price = "Price : "
        static let count = "Quantity : "
        static let subtotal = "Sub Total : "
        static let errorTitle = "Cart"
        static let cantFetch = "The product cannot be fetched at this moment. Please try again!!!"
        static let unknown = "Oops something went wrong!!!"
    }
    
    // MARK: CartPresentationLogic implementation
    func presentProducts(response: Cart.FetchProducts.Response){
        if let products = response.products{
            let viewModel = getProductViewModel(products: products)
            viewController?.displayProducts(viewModel: viewModel)
        }
        else{
            let viewModel = self.getErrorModel(response: response)
            viewController?.displayError(viewModel: viewModel)
        }
    }
    
    func removedProduct(response: Cart.RemoveProduct.Response){
        if let success = response.success{
            let viewModel = Cart.RemoveProduct.ProductViewModel(success: success, title: "Deleted", message: "Deleted successfully")
            viewController?.removedFromCart(viewModel: viewModel)
        }
        else{
            let viewModel = Cart.RemoveProduct.ErrorViewModel(title: "Title", message: "Messae")
            viewController?.displayError(viewModel: viewModel)
        }
    }
    
    private func getProductViewModel(products : [Product]) -> Cart.FetchProducts.ProductViewModel{
        var displayedProducts : [Cart.ViewModel.DisplayedProduct] = []
        for p in products{
            let name = AppUtil.getAttributedString(from: Titles.name, subTitle: p.name)
            let category = AppUtil.getAttributedString(from: Titles.category, subTitle: "\(p.category)")
            let price = AppUtil.getAttributedString(from: Titles.price, subTitle: "\(p.price)")
            let count = AppUtil.getAttributedString(from: Titles.count,subTitle: "\(p.count)")
            let subtotal = AppUtil.getAttributedString(from: Titles.subtotal,subTitle: "\(p.price*Double(p.count))")
            
            let displayedProduct = Cart.ViewModel
                .DisplayedProduct(id: p.id, name: name, category: category, price: price, image: p.images.first!, count: count, subtotal: subtotal,priceValue:p.price,countValue:p.count)
            
            displayedProducts.append(displayedProduct)
        }
        return Cart.FetchProducts.ProductViewModel(displayedProducts: displayedProducts)
    }
    
    private func getErrorModel(response : Cart.FetchProducts.Response) -> Cart.FetchProducts.ErrorViewModel{
        let title = Titles.errorTitle
        var message = Titles.unknown
        
        guard let error = response.error else{
            return Cart.FetchProducts.ErrorViewModel(title: title, message: message)
        }
        
        switch(error){
        case .CannotFetch(_):
            message = Titles.cantFetch
        default:
            message = Titles.unknown
        }
        
        return Cart.FetchProducts.ErrorViewModel(title: title, message: message)
    }
}
